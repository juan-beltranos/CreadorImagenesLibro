<!DOCTYPE html>
<html>

<head>
    <title>Pokémon Coloring Book</title>
</head>

<body>
    <button id="generate">Generate Coloring Book</button>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.4.0/jspdf.umd.min.js"></script>
    <script>

        const { jsPDF } = window.jspdf;

        document.getElementById('generate').addEventListener('click', async () => {
            const doc = new jsPDF();
            const pageWidth = doc.internal.pageSize.getWidth();
            const pageHeight = doc.internal.pageSize.getHeight();
            const imageWidth = pageWidth * 0.8;
            const imageHeight = pageHeight * 0.8;
            const xOffset = (pageWidth - imageWidth) / 2;
            const yOffset = (pageHeight - imageHeight) / 2;

            const pokeAPI = 'https://pokeapi.co/api/v2/pokemon?limit=10';

            const response = await fetch(pokeAPI);
            const data = await response.json();
            const pokemons = data.results;

            for (let i = 0; i < pokemons.length; i++) {

                const imageUrl = `https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/other/home/${i}.png`;
                const image = await loadImage(imageUrl);
                // Blanco y negro
                const sketch = convertToSketch(image);

                doc.addImage(image, 'PNG', xOffset, yOffset, imageWidth, imageHeight); // Ajustar al 80% de la página
                if (i < pokemons.length - 1) {
                    doc.addPage();
                }
            }

            doc.save('pokemon_coloring_book.pdf');
        });

        function loadImage(url) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.crossOrigin = 'Anonymous';
                img.onload = () => resolve(img);
                img.onerror = () => reject(new Error('Failed to load image'));
                img.src = url;
            });
        }

        function convertToSketch(image) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = image.width;
            canvas.height = image.height;
            ctx.drawImage(image, 0, 0);
            const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imgData.data;

            // Convert image to grayscale
            for (let i = 0; i < data.length; i += 4) {
                const avg = (data[i] + data[i + 1] + data[i + 2]) / 3;
                data[i] = avg;
                data[i + 1] = avg;
                data[i + 2] = avg;
                data[i + 3] = 255;
            }

            // Edge detection using Sobel operator
            const sobelData = sobelFilter(imgData);
            ctx.putImageData(sobelData, 0, 0);

            return canvas.toDataURL('image/png');
        }

        function sobelFilter(imgData) {
            const width = imgData.width;
            const height = imgData.height;
            const data = imgData.data;
            const grayscale = new Uint8ClampedArray(data.length / 4);

            // Convert image to grayscale
            for (let i = 0; i < data.length; i += 4) {
                const avg = (data[i] + data[i + 1] + data[i + 2]) / 3;
                grayscale[i / 4] = avg;
            }

            const sobelData = new Uint8ClampedArray(data.length);

            const kernelX = [
                [-1, 0, 1],
                [-2, 0, 2],
                [-1, 0, 1]
            ];

            const kernelY = [
                [-1, -2, -1],
                [0, 0, 0],
                [1, 2, 1]
            ];

            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    let pixelX = 0;
                    let pixelY = 0;

                    for (let ky = -1; ky <= 1; ky++) {
                        for (let kx = -1; kx <= 1; kx++) {
                            const pos = (y + ky) * width + (x + kx);
                            const val = grayscale[pos];
                            pixelX += val * kernelX[ky + 1][kx + 1];
                            pixelY += val * kernelY[ky + 1][kx + 1];
                        }
                    }

                    const magnitude = Math.sqrt(pixelX * pixelX + pixelY * pixelY) >>> 0;
                    const index = (y * width + x) * 4;
                    sobelData[index] = sobelData[index + 1] = sobelData[index + 2] = magnitude > 128 ? 0 : 255;
                    sobelData[index + 3] = 255;
                }
            }

            return new ImageData(sobelData, width, height);
        }

    </script>
</body>

</html>